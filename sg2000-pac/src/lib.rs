#![doc = "Peripheral access API for SG2000 microcontrollers (generated using svd2rust v0.37.1 (untracked))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = r" Interrupt numbers, priority levels, and HART IDs."]
pub mod interrupt;
#[doc = "Platform-Level Interrupt Controller"]
pub type Plic = crate::Periph<plic::RegisterBlock, 0x7000_0000>;
impl core::fmt::Debug for Plic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Plic").finish()
    }
}
#[doc = "Platform-Level Interrupt Controller"]
pub mod plic;
#[doc = "Timer Interrupt Value"]
pub type Mtimecmp = crate::Periph<mtimecmp::RegisterBlock, 0x7400_4000>;
impl core::fmt::Debug for Mtimecmp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mtimecmp").finish()
    }
}
#[doc = "Timer Interrupt Value"]
pub mod mtimecmp;
#[doc = "GPIO0"]
pub type Gpio0 = crate::Periph<gpio0::RegisterBlock, 0x0302_0000>;
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "GPIO0"]
pub mod gpio0;
#[doc = "GPIO0"]
pub type Gpio1 = crate::Periph<gpio0::RegisterBlock, 0x0302_1000>;
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "GPIO0"]
pub use self::gpio0 as gpio1;
#[doc = "GPIO0"]
pub type Gpio2 = crate::Periph<gpio0::RegisterBlock, 0x0302_2000>;
impl core::fmt::Debug for Gpio2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio2").finish()
    }
}
#[doc = "GPIO0"]
pub use self::gpio0 as gpio2;
#[doc = "GPIO0"]
pub type Gpio3 = crate::Periph<gpio0::RegisterBlock, 0x0302_3000>;
impl core::fmt::Debug for Gpio3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio3").finish()
    }
}
#[doc = "GPIO0"]
pub use self::gpio0 as gpio3;
#[doc = "GPIO0"]
pub type RtcsysGpio = crate::Periph<gpio0::RegisterBlock, 0x0502_1000>;
impl core::fmt::Debug for RtcsysGpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RtcsysGpio").finish()
    }
}
#[doc = "GPIO0"]
pub use self::gpio0 as rtcsys_gpio;
#[doc = "UART"]
pub type Uart0 = crate::Periph<uart0::RegisterBlock, 0x0414_0000>;
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "UART"]
pub mod uart0;
#[doc = "UART"]
pub type Uart1 = crate::Periph<uart0::RegisterBlock, 0x0415_0000>;
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART"]
pub use self::uart0 as uart1;
#[doc = "UART"]
pub type Uart2 = crate::Periph<uart0::RegisterBlock, 0x0416_0000>;
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART"]
pub use self::uart0 as uart2;
#[doc = "UART"]
pub type Uart3 = crate::Periph<uart0::RegisterBlock, 0x0417_0000>;
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART"]
pub use self::uart0 as uart3;
#[doc = "UART"]
pub type Uart4 = crate::Periph<uart0::RegisterBlock, 0x041c_0000>;
impl core::fmt::Debug for Uart4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart4").finish()
    }
}
#[doc = "UART"]
pub use self::uart0 as uart4;
#[doc = "UART"]
pub type RtcsysUart = crate::Periph<uart0::RegisterBlock, 0x0502_2000>;
impl core::fmt::Debug for RtcsysUart {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RtcsysUart").finish()
    }
}
#[doc = "UART"]
pub use self::uart0 as rtcsys_uart;
#[doc = "mailboxes"]
pub type Mailboxes = crate::Periph<mailboxes::RegisterBlock, 0x0190_0000>;
impl core::fmt::Debug for Mailboxes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailboxes").finish()
    }
}
#[doc = "mailboxes"]
pub mod mailboxes;
#[unsafe(no_mangle)]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "plic"]
    pub plic: Plic,
    #[doc = "mtimecmp"]
    pub mtimecmp: Mtimecmp,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "GPIO2"]
    pub gpio2: Gpio2,
    #[doc = "GPIO3"]
    pub gpio3: Gpio3,
    #[doc = "RTCSYS_GPIO"]
    pub rtcsys_gpio: RtcsysGpio,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "UART4"]
    pub uart4: Uart4,
    #[doc = "RTCSYS_UART"]
    pub rtcsys_uart: RtcsysUart,
    #[doc = "mailboxes"]
    pub mailboxes: Mailboxes,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        unsafe { DEVICE_PERIPHERALS = true }
        Peripherals {
            plic: unsafe { Plic::steal() },
            mtimecmp: unsafe { Mtimecmp::steal() },
            gpio0: unsafe { Gpio0::steal() },
            gpio1: unsafe { Gpio1::steal() },
            gpio2: unsafe { Gpio2::steal() },
            gpio3: unsafe { Gpio3::steal() },
            rtcsys_gpio: unsafe { RtcsysGpio::steal() },
            uart0: unsafe { Uart0::steal() },
            uart1: unsafe { Uart1::steal() },
            uart2: unsafe { Uart2::steal() },
            uart3: unsafe { Uart3::steal() },
            uart4: unsafe { Uart4::steal() },
            rtcsys_uart: unsafe { RtcsysUart::steal() },
            mailboxes: unsafe { Mailboxes::steal() },
        }
    }
}
